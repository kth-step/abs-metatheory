(* generated by Ott 0.33 from: src/abs.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Export Ascii.
Require Export String.

Require Import FMapList OrderedTypeEx.
Module Map <: FMapInterface.S := FMapList.Make String_as_OT.

Hint Resolve bool_dec : ott_coq_equality.
Hint Resolve ascii_dec : ott_coq_equality.

(** * ABS Definitions *)

Definition i : Set := nat. (*r index variables (subscripts) *)
Lemma eq_i: forall (x y : i), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_i : ott_coq_equality.
Definition fn : Set := string. (*r function name *)
Lemma eq_fn: forall (x y : fn), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_fn : ott_coq_equality.
Definition x : Set := string. (*r variable *)
Lemma eq_x: forall (x' y : x), {x' = y} + {x' <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_x : ott_coq_equality.

Inductive B : Set :=  (*r basic type *)
 | B_bool : B
 | B_int : B.

Inductive T : Set :=  (*r ground type *)
 | T_basic_type (B5:B).

Definition b : Set := bool.

Inductive sig : Set := 
 | sig_sig (_:list T) (T_5:T).

Inductive e : Set :=  (*r expression *)
 | e_b (b5:b) (*r boolean expression *)
 | e_var (x5:x) (*r variable *)
 | e_fn_call (fn5:fn) (_:list e) (*r function call *).

Inductive ctxv : Set := 
 | ctxv_T (T5:T)
 | ctxv_sig (sig5:sig).

Inductive F : Set :=  (*r function definition *)
 | F_fn (T_5:T) (fn5:fn) (_:list (T*x)) (e5:e).

Definition G : Type := Map.t ctxv.
(** induction principles *)
Section e_rect.

Variables
  (P_e : e -> Prop)
  (P_list_e : list e -> Prop).

Hypothesis
  (H_e_b : forall (b5:b), P_e (e_b b5))
  (H_e_var : forall (x5:x), P_e (e_var x5))
  (H_e_fn_call : forall (e_list:list e), P_list_e e_list -> forall (fn5:fn), P_e (e_fn_call fn5 e_list))
  (H_list_e_nil : P_list_e nil)
  (H_list_e_cons : forall (e0:e), P_e e0 -> forall (e_l:list e), P_list_e e_l -> P_list_e (cons e0 e_l)).

Fixpoint e_ott_ind (n:e) : P_e n :=
  match n as x return P_e x with
  | (e_b b5) => H_e_b b5
  | (e_var x5) => H_e_var x5
  | (e_fn_call fn5 e_list) => H_e_fn_call e_list (((fix e_list_ott_ind (e_l:list e) : P_list_e e_l := match e_l as x return P_list_e x with nil => H_list_e_nil | cons e1 xl => H_list_e_cons e1(e_ott_ind e1)xl (e_list_ott_ind xl) end)) e_list) fn5
end.

End e_rect.
(** definitions *)

(* defns functional_well_typing *)
Inductive t_e : G -> e -> T -> Prop :=    (* defn e *)
 | t_bool : forall (G5:G) (b5:b),
     t_e G5 (e_b b5) (T_basic_type B_bool)
 | t_var : forall (G5:G) (x5:x) (T5:T),
      (Map.find  x5   G5  = Some (ctxv_T  T5 ))  ->
     t_e G5 (e_var x5) T5
 | t_func_expr : forall (e_T_list:list (e*T)) (G5:G) (fn5:fn) (T_5:T),
     (forall e_ T_, In (e_,T_) (map (fun (pat_: (e*T)) => match pat_ with (e_,T_) => (e_,T_) end) e_T_list) -> (t_e G5 e_ T_)) ->
      (Map.find  fn5   G5  = Some (ctxv_sig  (sig_sig (map (fun (pat_:(e*T)) => match pat_ with (e_,T_) => T_ end ) e_T_list) T_5) ))  ->
     t_e G5 (e_fn_call fn5 (map (fun (pat_:(e*T)) => match pat_ with (e_,T_) => e_ end ) e_T_list)) T_5
with t_F : G -> F -> Prop :=    (* defn F *)
 | t_func_decl : forall (T_x_list:list (T*x)) (G5:G) (T_5:T) (fn5:fn) (e5:e),
      (Map.find  fn5   G5  = Some (ctxv_sig  (sig_sig (map (fun (pat_:(T*x)) => match pat_ with (T_,x_) => T_ end ) T_x_list) T_5) ))  ->
     t_e  (fold_right (fun (ax : x * T) (G5 : G) => Map.add (fst ax) (ctxv_T (snd ax)) G5)  G5   (map (fun (pat_:(T*x)) => match pat_ with (T_,x_) => (x_,T_) end ) T_x_list) )  e5 T_5 ->
     t_F G5 (F_fn T_5 fn5 T_x_list e5).


