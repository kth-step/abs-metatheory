embed
{{ coq
Require Export Ascii.
Require Export String.

Require Import FMapList OrderedTypeEx.
Module Map <: FMapInterface.S := FMapList.Make String_as_OT.

Hint Resolve bool_dec : ott_coq_equality.
Hint Resolve ascii_dec : ott_coq_equality.

(** * ABS Definitions *)
}}
indexvar i, j, n ::=
      {{ lex numeral }}
      {{ coq nat }}
      {{ coq-equality }}
      {{ com index variables (subscripts) }}
metavar fn ::=
      {{ lex Alphanum }}
      {{ coq string }}
      {{ coq-equality }}
      {{ com function name }}
metavar x, y ::=
      {{ lex alphanum }}
      {{ coq string }}
      {{ coq-equality }}
      {{ com variable }}
grammar
T :: T_ ::=
   {{ com ground type }}
  | B :: :: basic_type

B :: B_ ::=
  {{ com basic type }}
  | Bool :: :: bool 
  | Int  :: :: int

F :: F_ ::=
  {{ com function definition }}
  | def T fn ( T1 x1 , ... , Tn xn ) = e ; :: :: fn

b :: b_ ::=
  {{ com boolean }}
  {{ coq bool }}
  {{ coq-equality }}
  | True :: M :: true
    {{ coq true }}
  | False :: M :: false
    {{ coq false }}

e :: e_ ::=
  {{ com expression }}
  | b :: :: b
    {{ com boolean expression }}
  | x :: :: var
    {{ com variable }}
  | fn ( e1 , ... , en ) :: :: fn_call
    {{ com function call }}

sig :: sig_ ::=
     | T1 , ... , Tn -> T :: :: sig

ctxv :: ctxv_ ::=
     | T :: :: T
     | sig :: :: sig

G {{ tex \Gamma }} :: G_ ::=
  {{ coq Map.t ctxv }}
  {{ coq-universe Type }}
   | G [ x1 |-> T1 , ... , xn |-> Tn ] :: M :: add_list
     {{ coq (fold_right (fun (ax : x * T) (G5 : G) => Map.add (fst ax) (ctxv_T (snd ax)) G5) [[G]] [[x1 |-> T1 ... xn |-> Tn]]) }}

terminals :: terminals_ ::=
  	  | {  :: :: leftbrace {{ tex \{ }}
	  | }  :: :: rightbrace {{ tex \} }}
	  | Bool :: :: bool {{ tex \mathsf{Bool} }}
	  | Int :: :: int {{ tex \mathsf{Int} }}
	  | True :: :: true {{ tex \mathrm{True} }}
	  | False :: :: false {{ tex \mathrm{False} }}
          | ~>  :: :: trans {{ tex \leadsto }}
	  | |- :: :: turnstile {{ tex \vdash }}
	  | |->  :: :: mapsto {{ tex \mapsto }}
  	  | ->  :: :: arrow {{ tex \rightarrow }}

formula :: formula_ ::= 
  {{ com formulas }}
  | judgement :: :: judgement
    {{ com judgment }}
  | formula1 ... formulan :: :: dots
    {{ com conjunction of formulas }}
  | G ( x ) = T :: M :: G_eq_T
    {{ coq (Map.find [[x]] [[G]] = Some (ctxv_T [[T]])) }}
  | G ( fn ) = sig :: M :: G_fn_eq_sig
    {{ coq (Map.find [[fn]] [[G]] = Some (ctxv_sig [[sig]])) }}

defns
  functional_well_typing :: t_ ::= 

defn 
  G |- e : T :: :: e :: ''
    {{ com well-typed expression }} by
  
  ------------- :: bool
  G |- b : Bool

  G ( x ) = T
  ----------- :: var
  G |- x : T

  G |- e1 : T1 ... G |- en : Tn
  G ( fn ) = T1 , ... , Tn -> T
  ----------------------------- :: func_expr
  G |- fn ( e1 , ... , en ) : T

defn
  G |- F :: :: F :: ''
    {{ com well-typed function declaration }} by

  G ( fn ) = T1 , ... , Tn -> T
  G [ x1 |-> T1 , ... , xn |-> Tn ] |- e : T
  ------------------------------------------- :: func_decl
  G |- def T fn ( T1 x1 , ... , Tn xn ) = e ;
