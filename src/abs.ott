embed
{{ coq
Require Export Ascii.
Require Export String.
Require Export ZArith.

Require Import FMapList OrderedTypeEx.
Module Map <: FMapInterface.S := FMapList.Make String_as_OT.

#[export] Hint Resolve bool_dec : ott_coq_equality.
#[export] Hint Resolve ascii_dec : ott_coq_equality.
#[export] Hint Resolve Pos.eq_dec : ott_coq_equality.

(** * ABS Definitions *)
}}
indexvar i, j, n ::=
      {{ lex numeral }}
      {{ coq nat }}
      {{ coq-equality }}
      {{ com index variables (subscripts) }}
metavar fn ::=
      {{ lex Alphanum }}
      {{ coq string }}
      {{ coq-equality }}
      {{ com function name }}
metavar x, y ::=
      {{ lex alphanum }}
      {{ coq string }}
      {{ coq-equality }}
      {{ com variable }}
metavar b ::=
  {{ lex alphanum }}
  {{ com boolean }}
  {{ coq-equality }}
  {{ coq bool }}
metavar z ::=
  {{ lex numeral }}
  {{ com integer }}
  {{ coq-equality }}
  {{ coq Z }}
grammar
T :: T_ ::=
   {{ com ground type }}
  | Bool :: :: bool 
  | Int  :: :: int

F :: F_ ::=
  {{ com function definition }}
  | def T fn ( T1 x1 , ... , Tn xn ) = e ; :: :: fn

t :: t_ ::=
  {{ com ground term }}
  | b :: :: b
    {{ com boolean }}
  | z :: :: int
    {{ com integer }}

e :: e_ ::=
  {{ com expression }}
  | t :: :: t
    {{ com term }}
  | x :: :: var
    {{ com variable }}
  | fn ( e1 , ... , en ) :: :: fn_call
    {{ com function call }}
  | e [ x1 |-> y1 , ... , xn |-> yn ] :: M :: subst_var
    {{ coq ([[e]]) }} % FIXME

sig :: sig_ ::=
     | T1 , ... , Tn -> T :: :: sig

ctxv :: ctxv_ ::=
     | T :: :: T
     | sig :: :: sig

G {{ tex \Gamma }} :: G_ ::=
  {{ coq Map.t ctxv }}
  {{ coq-universe Type }}
   | G [ x1 |-> T1 , ... , xn |-> Tn ] :: M :: add_list
     {{ coq (fold_right (fun (ax : x * T) (G5 : G) => Map.add (fst ax) (ctxv_T (snd ax)) G5) [[G]] [[x1 |-> T1 ... xn |-> Tn]]) }}

s {{ tex \sigma }} :: s_ ::=
  {{ coq Map.t t }}
  {{ coq-universe Type }}
   | s [ x1 |-> t1 , ... , xn |-> tn ] :: M :: add_list
     {{ coq (fold_right (fun (xt : x * t) (s5 : s) => Map.add (fst xt) (snd xt) s5) [[s]] [[x1 |-> t1 ... xn |-> tn]]) }}

terminals :: terminals_ ::=
  | Bool :: :: bool {{ tex \mathsf{Bool} }}
  | Int :: :: int {{ tex \mathsf{Int} }}
  | ~>  :: :: trans {{ tex \leadsto }}
  | |- :: :: turnstile {{ tex \vdash }}
  | |->  :: :: mapsto {{ tex \mapsto }}
  | ->  :: :: arrow {{ tex \rightarrow }}
  | fresh :: :: fresh {{ tex \mathsf{fresh} }}

formula :: formula_ ::= 
  {{ com formulas }}
  | judgement :: :: judgement
    {{ com judgment }}
  | formula1 ... formulan :: :: dots
    {{ com conjunction of formulas }}
  | G ( x ) = T :: M :: G_eq_T
    {{ coq (Map.find [[x]] [[G]] = Some (ctxv_T [[T]])) }}
  | s ( x ) = t :: M :: s_eq_t
    {{ coq (Map.find [[x]] [[s]] = Some ([[t]])) }}
  | G ( fn ) = sig :: M :: G_fn_eq_sig
    {{ coq (Map.find [[fn]] [[G]] = Some (ctxv_sig [[sig]])) }}
  | fresh ( x1 , ... , xn , e ) :: M :: fresh
    {{ coq True }} % FIXME

defns
  expression_well_typing :: typ_ ::=

defn 
  G |- e : T :: :: e :: ''
    {{ com well-typed expression }} by
  
  ------------- :: bool
  G |- b : Bool

  ------------ :: int
  G |- z : Int

  G ( x ) = T
  ----------- :: var
  G |- x : T

  G |- e1 : T1 ... G |- en : Tn
  G ( fn ) = T1 , ... , Tn -> T
  ----------------------------- :: func_expr
  G |- fn ( e1 , ... , en ) : T

defns
  function_well_typing :: typ_ ::=

defn
  G |- F :: :: F :: ''
    {{ com well-typed function declaration }} by

  G ( fn ) = T1 , ... , Tn -> T
  G [ x1 |-> T1 , ... , xn |-> Tn ] |- e : T
  ------------------------------------------- :: func_decl
  G |- def T fn ( T1 x1 , ... , Tn xn ) = e ;

defns
  evaluation_reduction :: red_ ::=

defn
  F1 ... Fn , s |- e ~> s' |- e' :: :: e :: ''
  {{ com expression evaluation }} by

  s ( x ) = t
  ---------------------------- :: var
  F1 ... Fn , s |- x ~> s |- t

  F1 ... Fn , s |- e ~> s' |- e'
  ------------------------------------------------------------------------------------------------------------- :: fun_exp
  F1 ... Fn , s |- fn ( e1 , ... , ei , e , e'1 , ... , e'j ) ~> s' |- fn ( e1 , ... , ei , e' , e'1 , ... , e'j )

  fresh ( y1 , ... , yn , e )
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- :: fun_ground
  F1 ... Fi def T fn ( T1 x1 , ... , Tn xn ) = e ; F'1 ... F'j , s |- fn ( t1 , ... , tn ) ~> s [ y1 |-> t1 , ... , yn |-> tn ] |- e [ x1 |-> y1 , ... , xn |-> yn ]
