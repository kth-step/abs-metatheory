embed
{{ coq
Require Export Ascii.
Require Export String.
Require Export ZArith.
Require Import Lia.
Require Coq.Program.Wf.

Require Import FMapList OrderedTypeEx.
Module Map <: FMapInterface.S := FMapList.Make String_as_OT.

#[export] Hint Resolve bool_dec : ott_coq_equality.
#[export] Hint Resolve ascii_dec : ott_coq_equality.
#[export] Hint Resolve Pos.eq_dec : ott_coq_equality.

(** * ABS Definitions *)
}}
indexvar i, j, n ::=
      {{ lex numeral }}
      {{ coq nat }}
      {{ coq-equality }}
      {{ com index variables (subscripts) }}
metavar fn ::=
      {{ lex Alphanum }}
      {{ coq string }}
      {{ coq-equality }}
      {{ com function name }}
metavar x, y ::=
      {{ lex alphanum }}
      {{ coq string }}
      {{ coq-equality }}
      {{ com variable }}
metavar b ::=
  {{ lex alphanum }}
  {{ com boolean }}
  {{ coq-equality }}
  {{ coq bool }}
metavar z ::=
  {{ lex numeral }}
  {{ com integer }}
  {{ coq-equality }}
  {{ coq Z }}
grammar
T :: T_ ::=
   {{ com ground type }}
  | Bool :: :: bool 
  | Int  :: :: int

F :: F_ ::=
  {{ com function definition }}
  | def T fn ( T1 x1 , ... , Tn xn ) = e ; :: :: fn

t :: t_ ::=
  {{ com ground term }}
  | b :: :: b
    {{ com boolean }}
  | z :: :: int
    {{ com integer }}

e :: e_ ::=
  {{ com expression }}
  | t :: :: t
    {{ com term }}
  | x :: :: var
    {{ com variable }}
  | fn ( e1 , ... , en ) :: :: fn_call
    {{ com function call }}
  | e [ x1 |-> y1 , ... , xn |-> yn ] :: M :: subst_var
    {{ coq (my_subst [[e]] [[x1 |-> y1 ... xn |-> yn]]) }}

sig :: sig_ ::=
     | T1 , ... , Tn -> T :: :: sig

ctxv :: ctxv_ ::=
     | T :: :: T
     | sig :: :: sig

G {{ tex \Gamma }} :: G_ ::=
  {{ coq Map.t ctxv }}
  {{ coq-universe Type }}
   | G [ x1 |-> T1 , ... , xn |-> Tn ] :: M :: add_list
     {{ coq (fold_right (fun (ax : x * T) (G5 : G) => Map.add (fst ax) (ctxv_T (snd ax)) G5) [[G]] [[x1 |-> T1 ... xn |-> Tn]]) }}

s {{ tex \sigma }} :: s_ ::=
  {{ coq Map.t t }}
  {{ coq-universe Type }}
   | s [ x1 |-> t1 , ... , xn |-> tn ] :: M :: add_list
     {{ coq (fold_right (fun (xt : x * t) (s5 : s) => Map.add (fst xt) (snd xt) s5) [[s]] [[x1 |-> t1 ... xn |-> tn]]) }}

terminals :: terminals_ ::=
  | Bool :: :: bool {{ tex \mathsf{Bool} }}
  | Int :: :: int {{ tex \mathsf{Int} }}
  | ~>  :: :: trans {{ tex \leadsto }}
  | |- :: :: turnstile {{ tex \vdash }}
  | |->  :: :: mapsto {{ tex \mapsto }}
  | ->  :: :: arrow {{ tex \rightarrow }}
  | fresh :: :: fresh {{ tex \mathsf{fresh} }}

formula :: formula_ ::= 
  {{ com formulas }}
  | judgement :: :: judgement
    {{ com judgment }}
  | formula1 ... formulan :: :: dots
    {{ com conjunction of formulas }}
  | G ( x ) = T :: M :: G_eq_T
    {{ coq (Map.find [[x]] [[G]] = Some (ctxv_T [[T]])) }}
  | s ( x ) = t :: M :: s_eq_t
    {{ coq (Map.find [[x]] [[s]] = Some ([[t]])) }}
  | G ( fn ) = sig :: M :: G_fn_eq_sig
    {{ coq (Map.find [[fn]] [[G]] = Some (ctxv_sig [[sig]])) }}
  | fresh ( x1 , ... , xn , e ) :: M :: fresh
    {{ coq (my_fresh [[x1 ... xn]] [[e]]) }}

embed
{{ coq
Fixpoint get_val (k:x) (l:list(x*x)): option x :=
  match l with
  | nil => None
  | (k', v) :: l' =>
      match eq_x k k' with
      | left _ => Some v
      | _ => get_val k l'
      end
  end.

Fixpoint my_subst (e5:e) (l:list (x*x)) : e :=
  match e5 with
  | e_t t => e_t t
  | e_var x =>
      match get_val x l with
              | None => e_var x
              | Some y => e_var y
              end
  | e_fn_call fn e_list =>
      e_fn_call fn (map (fun e => my_subst e l) e_list)
  end.

(* we actually need to do some work to convince Coq my_fresh is well founded *)
Fixpoint e_size (e0 : e) : nat :=
  match e0 with
  | e_t _ => 1
  | e_var _ => 1
  | e_fn_call _ es => 1 + list_sum (map e_size es)
  end.

Lemma size_ge_1: forall e0,
     1 <= e_size e0.
Proof. destruct e0;cbn;lia. Qed.

Program Fixpoint my_fresh (l : list x) (e0 : e) {measure (e_size e0)} : Prop :=
  match e0 with
  | e_t _ => True
  | e_var x => ~ In x l
  | e_fn_call fn es =>
      match es with
      | nil => True
      | e1::es' => my_fresh l e1
                 /\ my_fresh l (e_fn_call fn es')
      end
  end.

Next Obligation. cbn;lia. Defined.
Next Obligation.
  induction es';cbn; specialize (size_ge_1 e1);intro; lia.
Defined.

}}

defns
  expression_well_typing :: typ_ ::=

defn 
  G |- e : T :: :: e :: ''
    {{ com well-typed expression }} by
  
  ------------- :: bool
  G |- b : Bool

  ------------ :: int
  G |- z : Int

  G ( x ) = T
  ----------- :: var
  G |- x : T

  G |- e1 : T1 ... G |- en : Tn
  G ( fn ) = T1 , ... , Tn -> T
  ----------------------------- :: func_expr
  G |- fn ( e1 , ... , en ) : T

defns
  function_well_typing :: typ_ ::=

defn
  G |- F :: :: F :: ''
    {{ com well-typed function declaration }} by

  G ( fn ) = T1 , ... , Tn -> T
  G [ x1 |-> T1 , ... , xn |-> Tn ] |- e : T
  ------------------------------------------- :: func_decl
  G |- def T fn ( T1 x1 , ... , Tn xn ) = e ;

defns
  evaluation_reduction :: red_ ::=

defn
  F1 ... Fn , s |- e ~> s' |- e' :: :: e :: ''
  {{ com expression evaluation }} by

  s ( x ) = t
  ---------------------------- :: var
  F1 ... Fn , s |- x ~> s |- t

  F1 ... Fn , s |- e ~> s' |- e'
  ------------------------------------------------------------------------------------------------------------- :: fun_exp
  F1 ... Fn , s |- fn ( e1 , ... , ei , e , e'1 , ... , e'j ) ~> s' |- fn ( e1 , ... , ei , e' , e'1 , ... , e'j )

  fresh ( y1 , ... , yn , e )
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- :: fun_ground
  F1 ... Fi def T fn ( T1 x1 , ... , Tn xn ) = e ; F'1 ... F'j , s |- fn ( t1 , ... , tn ) ~> s [ y1 |-> t1 , ... , yn |-> tn ] |- e [ x1 |-> y1 , ... , xn |-> yn ]
